---
title: "225 Building Environment Report"
author: "NEU Seattle Devs (Hot Sauce)"
date: "`r Sys.Date()`"

# Document Configuration
format:
  pdf:
    documentclass: article
    papersize: letter
    fontsize: 12pt
    geometry: 
      - margin=1in
    number-sections: true
    colorlinks: true
    link-citations: true
    keep-tex: true
    toc: true

# Execution Settings  
execute:
  echo: false
  warning: false
  error: false
  message: false
  fig-align: center

# Page Layout and Style
header-includes:
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhf{}
  - \rhead{NEU Seattle Devs}
  - \lhead{225 Building Environment Report}
  - \cfoot{\thepage}
  - \usepackage{xcolor}
  - \definecolor{darkblue}{RGB}{32, 38, 115}
  - \usepackage{sectsty}
  - \sectionfont{\color{darkblue}}
---


```{python}
import pandas as pd
import matplotlib.pyplot as plt
import os
from datetime import datetime
from collections import defaultdict
from data import report_type, selected_sensors, start_time, end_time, date_range

# Setup
output_dir = "charts"
os.makedirs(output_dir, exist_ok=True)

# Load data (assumed to be passed in as 'sensor_df.csv')
df = pd.read_csv("sensor_data.csv")

# Parse Timestamp
df['Timestamp'] = pd.to_datetime(df['Timestamp'])
df.sort_values(by='Timestamp', inplace=True)

# Separate by sensor
sensor_groups = df.groupby("Sensor ID")

# Function to generate charts for each metric
def plot_metric(metric, ylabel, filename_prefix, colors):
    plt.figure(figsize=(10, 5))
    for i, (sensor_id, group) in enumerate(sensor_groups):
        plt.plot(group['Timestamp'], group[metric], label=f"Sensor {sensor_id}", color=colors[i % len(colors)], marker='o')
    plt.xlabel("Timestamp")
    plt.ylabel(ylabel)
    plt.title(f"{metric} over Time")
    plt.legend(fontsize=8)
    plt.grid(True)
    filename = f"{output_dir}/{filename_prefix}.png"
    plt.savefig(filename, bbox_inches='tight', dpi=150)
    plt.close()


sensor_colors = [
    'red', 'orange', 'blue', 'green', 'purple', 'cyan',
    'teal', 'violet', 'black', 'gray', 'brown', 'magenta'
]

# Generate charts
plot_metric("Temperature", "Temperature (Â°C)", "temperature_chart", sensor_colors)
plot_metric("Humidity", "Humidity (%)", "humidity_chart", sensor_colors)
plot_metric("CO2", "CO2 (ppm)", "co2_chart", sensor_colors)
plot_metric("PM2.5", "PM2.5 (Âµg/mÂ³)", "pm_chart", sensor_colors)

# Data Summary
summary = df.groupby("Sensor ID").agg({
    "Temperature": ["min", "max"],
    "Humidity": ["min", "max"],
    "CO2": ["min", "max"],
    "PM2.5": ["min", "max"]
})
print(summary)

```

# Sensor Charts

## Temperature
![Temperature](/charts/temperature_chart.png){width=85%}

## Humidity
![Humidity](/charts/humidity_chart.png){width=85%}

## CO2
![CO2](/charts/co2_chart.png){width=85%}

## PM2.5
![PM2.5](/charts/pm_chart.png){width=85%}


# Comfort Level & Indoor Climate Score

```{python}
def calculate_penalty(value, optimal_range, penalty_factor):
    if optimal_range[0] <= value <= optimal_range[1]:
        return 0
    return abs(value - sum(optimal_range)/2) * penalty_factor

def calculate_ics(sensor_df):
    weights = {"Temperature": 0.3, "Humidity": 0.2, "CO2": 0.3, "PM2.5": 0.2}
    optimal_ranges = {"Temperature": (20, 25), "Humidity": (40, 60), "CO2": (400, 800), "PM2.5": (0, 12)}
    penalty_factors = {"Temperature": 5, "Humidity": 2, "CO2": 1/10, "PM2.5": 2}

    scores = []
    for _, row in sensor_df.iterrows():
        penalties = {key: calculate_penalty(row[key], optimal_ranges[key], penalty_factors[key]) for key in weights}
        ics = 100 - sum(weights[k] * penalties[k] for k in weights)
        scores.append(ics)
    return round(sum(scores)/len(scores), 2)

ics = calculate_ics(df)
print("Indoor Comfort Score:", ics)
```


**Comfort Levels:**

- Excellent (90-100) âœ…
- Good (75-89) ðŸ™‚
- Moderate (50-74) ðŸ˜
- Poor (25-49) ðŸ˜•
- Unacceptable (0-24) âŒ

---

**Sensor Models**: ESP8266, PMS5003(PM2.5), SHT31-D(Temp/Hum), S8(CO2)  
**Calibration Date**: January 15, 2025  
**Sampling Interval**: 5 minutes
